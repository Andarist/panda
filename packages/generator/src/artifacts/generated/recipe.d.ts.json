{
  "content": "import type { Pretty, DistributiveOmit, DistributivePick } from './helpers'\nimport type { SystemStyleObject } from './system-types'\n\ntype StringToBoolean<T> = T extends 'true' | 'false' ? boolean : T\n\nexport type RecipeVariantRecord = Record<any, Record<any, SystemStyleObject>>\n\nexport type RecipeSelection<T extends RecipeVariantRecord> = keyof any extends keyof T\n  ? {}\n  : {\n      [K in keyof T]?: StringToBoolean<keyof T[K]>\n    }\n\nexport type RecipeVariantFn<T extends RecipeVariantRecord> = (props?: RecipeSelection<T>) => string\n\nexport type RecipeVariantProps<\n  T extends RecipeVariantFn<RecipeVariantRecord> | SlotRecipeVariantFn<string, SlotRecipeVariantRecord<string>>,\n> = Pretty<Parameters<T>[0]>\n\ntype RecipeVariantMap<T extends RecipeVariantRecord> = {\n  [K in keyof T]: Array<keyof T[K]>\n}\n\n/* -----------------------------------------------------------------------------\n * Recipe / Standard\n * -----------------------------------------------------------------------------*/\n\nexport interface RecipeRuntimeFn<T extends RecipeVariantRecord> extends RecipeVariantFn<T> {\n  __type: RecipeSelection<T>\n  variantKeys: (keyof T)[]\n  variantMap: RecipeVariantMap<T>\n  raw: (props?: RecipeSelection<T>) => SystemStyleObject\n  config: RecipeConfig<T>\n  splitVariantProps<Props extends RecipeSelection<T>>(\n    props: Props,\n  ): [RecipeSelection<T>, Pretty<DistributiveOmit<Props, keyof T>>]\n}\n\ntype OneOrMore<T> = T | Array<T>\n\nexport type RecipeCompoundSelection<T> = { [K in keyof T]?: OneOrMore<StringToBoolean<keyof T[K]>> }\n\nexport type RecipeCompoundVariant<T> = T & {\n  css: SystemStyleObject\n}\n\nexport interface RecipeDefinition<T extends RecipeVariantRecord> {\n  /**\n   * The base styles of the recipe.\n   */\n  base?: SystemStyleObject\n  /**\n   * The multi-variant styles of the recipe.\n   */\n  variants?: T\n  /**\n   * The default variants of the recipe.\n   */\n  defaultVariants?: RecipeSelection<T>\n  /**\n   * The styles to apply when a combination of variants is selected.\n   */\n  compoundVariants?: Array<Pretty<RecipeCompoundVariant<RecipeCompoundSelection<T>>>>\n}\n\nexport type RecipeCreatorFn = <T extends RecipeVariantRecord>(config: RecipeDefinition<T>) => RecipeRuntimeFn<T>\n\ninterface RecipeConfigMeta {\n  /**\n   * The name of the recipe.\n   */\n  className: string\n  /**\n   * The description of the recipe. This will be used in the JSDoc comment.\n   */\n  description?: string\n  /**\n   * The jsx elements to track for this recipe. Can be string or Regexp.\n   *\n   * @default capitalize(recipe.name)\n   * @example ['Button', 'Link', /Button$/]\n   */\n  jsx?: Array<string | RegExp>\n}\n\nexport interface RecipeConfig<T extends RecipeVariantRecord = RecipeVariantRecord>\n  extends RecipeDefinition<T>,\n    RecipeConfigMeta {}\n\nexport interface RecipeBuilderConfig<T extends RecipeVariantRecord> {\n  /* Add additional or override variants */\n  extend: <TVariants extends RecipeVariantRecord>(variants: TVariants) => RecipeBuilder<Pretty<T & TVariants>>\n  /* Deep merge with another recipe */\n  merge: <TVariants extends RecipeVariantRecord, MergedVariants extends Pretty<TVariants & T> = Pretty<TVariants & T>>(\n    extension: Partial<Omit<RecipeConfig<any>, 'variants' | 'compoundVariants' | 'defaultVariants'>> & {\n      variants?: TVariants\n      compoundVariants?: Array<Pretty<RecipeCompoundVariant<RecipeCompoundSelection<MergedVariants>>>>\n      defaultVariants?: RecipeSelection<MergedVariants>\n    },\n  ) => RecipeBuilder<MergedVariants>\n  /* Pick only specified variants (also filter compoundVariants) */\n  pick: <TKeys extends keyof T>(...keys: TKeys[]) => RecipeBuilder<DistributivePick<T, TKeys>>\n  /* Omit specified variants (also filter compoundVariants) */\n  omit: <TKeys extends keyof T>(...keys: TKeys[]) => RecipeBuilder<DistributiveOmit<T, TKeys>>\n  /* Make the recipe generic to simplify the typings */\n  cast: () => RecipeConfig<RecipeVariantRecord>\n}\n\nexport interface RecipeBuilder<T extends RecipeVariantRecord> extends RecipeConfig<T> {\n  // config ? build ? api ?\n  config: RecipeBuilderConfig<T>\n}\n\n/* -----------------------------------------------------------------------------\n * Recipe / Slot\n * -----------------------------------------------------------------------------*/\n\ntype SlotRecord<S extends string, T> = Partial<Record<S, T>>\n\nexport type SlotRecipeVariantRecord<S extends string> = Record<any, Record<any, SlotRecord<S, SystemStyleObject>>>\n\nexport type SlotRecipeVariantFn<S extends string, T extends RecipeVariantRecord> = (\n  props?: RecipeSelection<T>,\n) => SlotRecord<S, string>\n\nexport interface SlotRecipeRuntimeFn<S extends string, T extends SlotRecipeVariantRecord<S>>\n  extends SlotRecipeVariantFn<S, T> {\n  raw: (props?: RecipeSelection<T>) => Record<S, SystemStyleObject>\n  variantKeys: (keyof T)[]\n  variantMap: RecipeVariantMap<T>\n  splitVariantProps<Props extends RecipeSelection<T>>(props: Props): [RecipeSelection<T>, Pretty<Omit<Props, keyof T>>]\n}\n\nexport type SlotRecipeCompoundVariant<S extends string, T extends RecipeVariantRecord> = RecipeCompoundSelection<T> & {\n  css: SlotRecord<S, SystemStyleObject>\n}\n\nexport interface SlotRecipeDefinition<S extends string, T extends SlotRecipeVariantRecord<S>> {\n  /**\n   * The parts/slots of the recipe.\n   */\n  slots: S[] | Readonly<S[]>\n  /**\n   * The base styles of the recipe.\n   */\n  base?: SlotRecord<S, SystemStyleObject>\n  /**\n   * The multi-variant styles of the recipe.\n   */\n  variants?: T | SlotRecipeVariantRecord<S>\n  /**\n   * The default variants of the recipe.\n   */\n  defaultVariants?: RecipeSelection<T>\n  /**\n   * The styles to apply when a combination of variants is selected.\n   */\n  compoundVariants?: Array<SlotRecipeCompoundVariant<S, T>>\n}\n\nexport type SlotRecipeCreatorFn = <S extends string, T extends SlotRecipeVariantRecord<S>>(\n  config: SlotRecipeDefinition<S, T>,\n) => SlotRecipeRuntimeFn<S, T>\n\nexport type SlotRecipeConfig<\n  S extends string = string,\n  T extends SlotRecipeVariantRecord<S> = SlotRecipeVariantRecord<S>,\n> = SlotRecipeDefinition<S, T> & RecipeConfigMeta\n\nexport interface SlotRecipeBuilderConfig<S extends string, T extends SlotRecipeVariantRecord<S>> {\n  /* Add additional or override variants */\n  extend: <TVariants extends SlotRecipeVariantRecord<S>>(\n    variants: TVariants,\n  ) => SlotRecipeBuilder<S, Pretty<T & TVariants>>\n  /* Deep merge with another Slotrecipe */\n  merge: <\n    TVariants extends SlotRecipeVariantRecord<S>,\n    MergedVariants extends Pretty<TVariants & T> = Pretty<TVariants & T>,\n  >(\n    extension: Partial<Omit<SlotRecipeConfig<any>, 'slots' | 'variants' | 'compoundVariants' | 'defaultVariants'>> & {\n      slots?: S[]\n      variants?: TVariants extends unknown ? SlotRecipeVariantRecord<S> : TVariants\n      compoundVariants?: Array<Pretty<RecipeCompoundVariant<RecipeCompoundSelection<MergedVariants>>>>\n      defaultVariants?: RecipeSelection<MergedVariants>\n    },\n  ) => SlotRecipeBuilder<S, MergedVariants>\n  /* Pick only specified variants (also filter compoundVariants) */\n  pick: <TKeys extends keyof T>(...keys: TKeys[]) => SlotRecipeBuilder<S, DistributivePick<T, TKeys>>\n  /* Omit specified variants (also filter compoundVariants) */\n  omit: <TKeys extends keyof T>(...keys: TKeys[]) => SlotRecipeBuilder<S, DistributiveOmit<T, TKeys>>\n  /* Make the Slotrecipe generic to simplify the typings */\n  cast: () => SlotRecipeConfig<S, SlotRecipeVariantRecord<S>>\n  /** Add slots, pick or omit some or assign a config recipe to a slot */\n  slots: SlotBuilderConfig<S, T>\n}\n\ntype PickSlots<S extends string, T extends SlotRecipeVariantRecord<S>, TKeys extends S> = Pretty<{\n  [VName in keyof T]: {\n    [VKey in keyof T[VName]]: {\n      [VSlot in Extract<keyof T[VName][VKey], TKeys>]: T[VName][VKey][VSlot]\n    }\n  }\n}>\n\ntype OmitSlots<S extends string, T extends SlotRecipeVariantRecord<S>, TKeys extends S> = Pretty<{\n  [VName in keyof T]: {\n    [VKey in keyof T[VName]]: {\n      [VSlot in Exclude<keyof T[VName][VKey], TKeys>]: T[VName][VKey][VSlot]\n    }\n  }\n}>\n\nexport interface SlotBuilderConfig<S extends string, T extends SlotRecipeVariantRecord<S>> {\n  /* Add additional slots */\n  add: <TSlots extends string>(\n    ...slots: TSlots[]\n  ) => SlotRecipeBuilder<S | TSlots, T extends SlotRecipeVariantRecord<S | TSlots> ? T : never>\n  /* Pick only specified slots (also filter base/variants/compoundVariants) */\n  pick: <TKeys extends S>(...keys: TKeys[]) => SlotRecipeBuilder<Extract<S, TKeys>, PickSlots<S, T, TKeys>>\n  /* Omit specified slots (also filter base/slots/compoundVariants) */\n  omit: <TKeys extends S>(...keys: TKeys[]) => SlotRecipeBuilder<Exclude<S, TKeys>, OmitSlots<S, T, TKeys>>\n  /** Assign simple recipe to slot */\n  assignTo: <\n    TSlot extends S,\n    TRecipe extends RecipeConfig,\n    TVariants extends NonNullable<TRecipe['variants']> = NonNullable<TRecipe['variants']>,\n  >(\n    slot: TSlot,\n    recipe: TRecipe,\n  ) => SlotRecipeBuilder<\n    S,\n    {\n      [VName in keyof T]: {\n        [VKey in keyof T[VName]]: {\n          [VSlot in keyof T[VName][VKey]]: VSlot extends TSlot\n            ? {\n                [VRecipeVariant in keyof TVariants]: VRecipeVariant extends VName\n                  ? TVariants[VRecipeVariant][VKey]\n                  : never\n              }[keyof TVariants]\n            : T[VName][VKey][VSlot]\n        }\n      }\n    }\n  >\n}\n\nexport interface SlotRecipeBuilder<S extends string, T extends SlotRecipeVariantRecord<S>>\n  extends SlotRecipeConfig<S, T> {\n  // config ? build ? api ?\n  config: SlotRecipeBuilderConfig<S, T>\n}\n"
}